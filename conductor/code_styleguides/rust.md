# Rust コーディング規約

## 全般
- **Rust 標準の遵守:** `rustfmt` を常に使用し、標準的な命名規則（蛇法、PascalCaseなど）に従います。
- **Clipy の活用:** `cargo clippy` を定期的に実行し、推奨される書き方に修正します。
- **所有権と借用:** 不必要な `clone()` を避け、借用とライフタイムを適切に管理します。

## 関数型ドメインモデリング (DMMF)
- **代数データ型 (ADT) の活用:** ビジネス概念を Rust の `enum` で表現し、不可能な状態を型で排除します。
- **ドメインロジックの純粋性:** ドメイン層は副作用を持たない純粋な関数として実装し、エラーは `Result` 型で表現します。
- **Newtype パターン:** プリミティブな型（`String`, `u32` など）をそのまま使わず、ドメインの文脈に合わせた Newtype を作成して型安全性を高めます。
- **Domain Service:** 複数のドメインモデルに跨るロジックや、ドメインの一意性検証などの副作用（リポジトリへの問い合わせ等）を伴うドメイン知識は Domain Service として定義します。

## アーキテクチャ固有の規約
- **叫ぶディレクトリ構造:** `src/auth/`, `src/users/` のように、機能名がディレクトリ名になるように配置します。
- **Ports と Adapters の分離:** トレイトを Port（インターフェース）として定義し、その実装を Adapter として分離します。
- **UseCase 層:** ビジネスシナリオを表現する層として `libs/domain/src/usecase` に配置します。UseCase は TransactionManager を通じてリポジトリを操作し、ビジネスプロセスをオーケストレーションします。
- **トランザクション管理:** 複数のリポジトリ操作を伴う UseCase では `tx!` マクロを使用し、ACID 特性を保証します。TransactionManager と RepositoryFactory を介してリポジトリにアクセスします。
- **モジュール境界:** `pub(crate)` を適切に使用し、モジュールのカプセル化を徹底します。

## エラーハンドリング
- **独自エラー型:** 各ドメインごとに `thiserror` 等を用いて独自のエラー型を定義します。
- **不変条件のチェック:** コンストラクタ（`new` メソッド）でドメインの不変条件を検証し、常に有効なオブジェクトのみが生成されるようにします。
