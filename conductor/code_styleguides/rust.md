# Rust コーディング規約 & ベストプラクティス

## 全般
- **Rust 標準の遵守:** `rustfmt` を常に使用し、標準的な命名規則に従います。
- **コミット前フォーマット:** `git add` 前に必ず `cargo make fmt` を実行します。
- **Clipy の活用:** `cargo make clippy` を定期的に実行し、警告をゼロに保ちます。

## 関数型ドメインモデリング (DMMF)
- **代数データ型 (ADT) の活用:** ビジネス概念を Rust の `enum` で表現し、不可能な状態を型で排除します。
- **ドメインロジックの純粋性:** ドメイン層は副作用を持たない純粋な関数として実装し、エラーは `Result` 型で表現します。
- **Newtype パターン:** プリミティブな型（`String`, `u32` など）をそのまま使わず、ドメインの文脈に合わせた Newtype を作成して型安全性を高めます。
- **不変条件の強制:** コンストラクタ（`new` メソッド）や `TryFrom` 実装により不変条件を検証し、常に有効なオブジェクトのみが生成されるようにします。
- **セキュリティと意図の分離:**
    - 生のパスワードからハッシュへの変換は `PasswordService` などのドメインサービスのみが許可されます。
    - DBからの復元など、バリデーション済みの値を再構成する場合は `from_str_unchecked` のような明示的なメソッド名を使用し、ドメインロジック内での安易な利用を抑制します。
- **Domain Service:** 複数のドメインモデルに跨るロジックや、ドメインの一意性検証などの副作用（リポジトリへの問い合わせ等）を伴うドメイン知識は Domain Service として定義します。

## エラーハンドリング（DMMF 応用）
- **高凝集なエラー定義:** エラー型はそのエラーを発生させる主体（値オブジェクトやサービス）のすぐ側に定義します。
- **階層構造の構築:**
    1. **Value Object Error:** 最小単位のバリデーションエラー。
    2. **Context/Model Error:** そのコンテキスト固有のエラー。`#[error(transparent)]` で下位エラーを統合します。
    3. **Domain Error:** UseCase が返す最終的なエラー型。
- **推移的 From 実装:** UseCase 層で `?` 演算子を簡潔に利用できるよう、`DomainError` に対して各コンテキストエラーからの `From` を手動で実装します。
- **型安全な失敗:** `String` を持つ抽象的なエラー（"Stringly-typed"）を避け、具体的なコンテキストをフィールドとして持つ構造化されたエラーを定義します。
- **論理違反の明示:** バグや到達不能コードには `Internal` ではなく `LogicViolation(&'static str)` を使用し、静的なメッセージを強制します。

## アーキテクチャ固有の規約
- **叫ぶディレクトリ構造:** `src/auth/`, `src/users/` のように、機能名がディレクトリ名になるように配置します。
- **Ports と Adapters の分離:** トレイトを Port（インターフェース）として定義し、その実装を Adapter として分離します。
- **ステートレスなドメインサービス:** ドメインサービスは自身でリポジトリを保持せず、メソッドの引数としてリポジトリ（Port）を受け取ります。これによりトランザクション境界内での実行が容易になります。
- **UseCase 層:** ビジネスシナリオを表現する層として `libs/domain/src/usecase` に配置します。UseCase は TransactionManager を通じてリポジトリを操作し、ビジネスプロセスをオーケストレーションします。
- **トランザクション管理:** 複数のリポジトリ操作を伴う UseCase では `tx!` マクロを使用し、ACID 特性を保証します。
- **ジェネリクスの活用:** `dyn Trait` の相性問題（async_trait との競合等）を避けるため、UseCase 層の実装ではジェネリクス（`<TM: TransactionManager>` 等）を優先します。

## テスト戦略
- **rstest の活用:** `fixture` によるデータ共通化と、`case` によるパラメータ化テストを標準とします。
- **テストの近接配置:** 単体テストは実装ファイル内の `mod tests` に同梱します。
- **手動スタブの利用:** `mockall` による自動生成モックが複雑になりすぎる場合、あるいはプロダクションコードの型定義をテストのために歪める必要がある場合は、迷わず手動の `Stub` 構造体を `mod tests` 内に作成します。
